
<!DOCTYPE html>
<html>
<head>
  <title>Business Throughput Widget v3 (Live Data)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Adding a subtle animation for when data loads */
    @keyframes fadeIn {
        from { opacity: 0.5; }
        to { opacity: 1; }
    }
    .fade-in {
        animation: fadeIn 0.5s ease-in-out;
    }
  </style>
  <script>
    // --- APPDYNAMICS CONFIGURATION ---
    const CONFIG = {
        controllerHost: "https://vodacomsa-prod.saas.appdynamics.com",
        appName: "VODAPAY_MOBILEGATEWAY",
        // The path to the specific metric you want to display live data for.
        callsPerMinuteMetricPath: "Overall Application Performance|Calls per Minute",
        businessHours: {
            start: 7, // 7 AM
            end: 19   // 7 PM
        }
    };
    // ------------------------------------

    /**
     * Fetches metric data from the AppDynamics REST API.
     * @param {string} metricPath - The full path of the metric to query.
     * @param {number} durationInMins - The time range for the query (e.g., 60 for the last hour).
     * @returns {Promise<Array<object>>} A promise that resolves to an array of metric value objects.
     */
    async function fetchAppDMetricData(metricPath, durationInMins) {
        // --- AUTHENTICATION ---
        // IMPORTANT: You MUST generate an API Client and Bearer Token in AppDynamics.
        // Go to Administration > API Clients and create a client with 'Applications and Dashboards' permissions.
        // Replace "PASTE_YOUR_BEARER_TOKEN_HERE" with your actual token.
        const bearerToken = "eyJraWQiOiIxZjk1ZGVjZS04NTNlLTQ0NWItOWIxZS0xZTk0N2RjYzkxM2YiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJBcHBEeW5hbWljcyIsImF1ZCI6IkFwcERfQVBJcyIsImp0aSI6IjRrbTUxWlFUdi1NejVMNlhsM2wtTkEiLCJzdWIiOiJKaGVzYWxfQVBJIiwiaWRUeXBlIjoiQVBJX0NMSUVOVCIsImlkIjoiYmYwYmJkZjQtMDYxNS00YzM0LTg3ZTAtYTQzMzg2YzZmMDAwIiwiYWNjdElkIjoiMWY5NWRlY2UtODUzZS00NDViLTliMWUtMWU5NDdkY2M5MTNmIiwidG50SWQiOiIxZjk1ZGVjZS04NTNlLTQ0NWItOWIxZS0xZTk0N2RjYzkxM2YiLCJhY2N0TmFtZSI6InZvZGFjb21zYS1wcm9kIiwidGVuYW50TmFtZSI6InZvZGFjb21zYS1wcm9kIiwiZm1tVG50SWQiOm51bGwsImFjY3RQZXJtIjpbXSwicm9sZUlkcyI6W10sImlhdCI6MTc1OTI5NzMwMywibmJmIjoxNzU5Mjk3MTgzLCJleHAiOjE3NTkzODM3MDMsInRva2VuVHlwZSI6IkFDQ0VTUyJ9.PsGj-ZEJVptlYWp4kgvsTjppEfKR_fRQ5qYOs7kPvUQ"; 
        // ----------------------

        if (bearerToken === "PASTE_YOUR_BEARER_TOKEN_HERE") {
            console.error("CRITICAL: Bearer Token is not set. The widget will not fetch data.");
            // Display an error on the widget itself
            document.getElementById('status-level').innerText = "Auth Error";
            document.getElementById('status-message').innerText = "API Bearer Token is missing in the HTML file.";
            return []; // Stop execution if the token isn't set
        }

        const url = `${CONFIG.controllerHost}/controller/rest/applications/${CONFIG.appName}/metric-data?metric-path=${encodeURIComponent(metricPath)}&time-range-type=BEFORE_NOW&duration-in-mins=${durationInMins}&output=JSON`;

        try {
            const response = await fetch(url, {
                headers: {
                    'Authorization': `Bearer ${bearerToken}`
                }
            });

            if (!response.ok) {
                console.error("Failed to fetch AppDynamics metric. Status:", response.status, response.statusText);
                return [];
            }
            const data = await response.json();
            return data[0]?.metricValues || [];
        } catch (error) {
            console.error("Error during fetch operation:", error);
            return [];
        }
    }


    /**
     * Main function to fetch data and update the widget's appearance.
     */
    async function refreshWidgetData() {
        // 1. Fetch metric values for the last 60 minutes.
        const metricValues = await fetchAppDMetricData(CONFIG.callsPerMinuteMetricPath, 60);

        if (metricValues.length === 0) {
            console.warn("No metric data returned. Widget will not be updated.");
            return;
        }

        // 2. Calculate current and average throughput.
        const currentCallsPerMinute = metricValues[metricValues.length - 1]?.value || 0;
        const total = metricValues.reduce((sum, item) => sum + item.value, 0);
        const averageThroughput = metricValues.length > 0 ? total / metricValues.length : 0;
        
        const data = {
            currentCallsPerMinute: Math.round(currentCallsPerMinute),
            averageThroughput: Math.round(averageThroughput)
        };

        // 3. Update the UI with the fetched data.
        updateWidgetUI(data);
    }
    
    // This part of the code defines the "look and feel" based on the data. It remains the same as before.
    function getRelativeStatus(current, average) {
       const percentageOfAverage = average > 0 ? (current / average) : 0;

      if (percentageOfAverage < 0.5) { return { level: "Critical Low", message: "Throughput is critically below the recent average.", colorClass: "bg-red-600"}; }
      else if (percentageOfAverage < 0.8) { return { level: "Warning Low", message: "Throughput is notably below the recent average.", colorClass: "bg-yellow-500"}; }
      else if (percentageOfAverage <= 1.2) { return { level: "Normal", message: "Operating within the expected range of the recent average.", colorClass: "bg-green-600"}; }
      else { return { level: "High Traffic", message: "Throughput is significantly above average, indicating a surge.", colorClass: "bg-blue-500"}; }
    }
    
    const ICONS = {
        "Critical Low": `<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>`,
        "Warning Low": `<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>`,
        "Normal": `<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>`,
        "High Traffic": `<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path></svg>`
    };
    
    function isBusinessHours(hoursConfig) {
        const currentHour = new Date().getHours();
        return currentHour >= hoursConfig.start && currentHour < hoursConfig.end;
    }
    
    /**
     * Updates the DOM elements with the new data.
     * @param {object} data - Contains currentCallsPerMinute and averageThroughput.
     */
    function updateWidgetUI(data) {
      const { currentCallsPerMinute, averageThroughput } = data;
      const status = getRelativeStatus(currentCallsPerMinute, averageThroughput);
      
      document.getElementById('current-throughput').innerText = currentCallsPerMinute;
      document.getElementById('status-level').innerText = status.level;
      document.getElementById('status-icon').innerHTML = ICONS[status.level];
      document.getElementById('status-message').innerText = status.message;
      
      const mainContainer = document.getElementById('widget-container');
      mainContainer.classList.remove('border-gray-700', 'border-red-600', 'border-yellow-500', 'border-blue-500', 'border-green-600');
      mainContainer.classList.add(`border-${status.colorClass.replace('bg-','')}`, 'fade-in');
       setTimeout(() => mainContainer.classList.remove('fade-in'), 500);

      const progressBar = document.getElementById('progress-bar');
      const progressPercentage = Math.min((currentCallsPerMinute / averageThroughput) * 100, 150); 
      progressBar.style.width = `${progressPercentage}%`;
      progressBar.classList.remove('bg-red-600', 'bg-yellow-500', 'bg-blue-500', 'bg-green-600');
      progressBar.classList.add(status.colorClass);

      document.getElementById('average-line').style.left = `${(100/150)*100}%`; 
      document.getElementById('average-text').innerText = `Avg: ${averageThroughput}`;

      const bizHoursIndicator = document.getElementById('business-hours-indicator');
      const inBusinessHours = isBusinessHours(CONFIG.businessHours);
      bizHoursIndicator.innerText = inBusinessHours ? 'Business Hours: ACTIVE' : 'Business Hours: INACTIVE';
      bizHoursIndicator.classList.toggle('text-green-400', inBusinessHours);
      bizHoursIndicator.classList.toggle('text-gray-500', !inBusinessHours);

      document.getElementById('legend-low').innerText = `< 80%`;
      document.getElementById('legend-normal').innerText = `80-120%`;
      document.getElementById('legend-high').innerText = `> 120%`;
    }

    // Run the widget update logic once the page loads, and then set it to refresh every 60 seconds.
    document.addEventListener('DOMContentLoaded', () => {
        refreshWidgetData();
        setInterval(refreshWidgetData, 60000); // Refresh every 1 minute
    });
  </script>
</head>
<body class="bg-gray-900 text-white font-sans p-4">
  <div id="widget-container" class="max-w-md mx-auto bg-gray-800 rounded-lg shadow-lg p-6 border-2 border-gray-700 transition-all duration-500">
    <div class="flex justify-between items-center mb-4">
      <h2 class="text-xl font-bold text-gray-200">Relative Throughput</h2>
      <div id="business-hours-indicator" class="text-sm font-medium"></div>
    </div>
    <div class="flex items-center space-x-6 bg-gray-900/50 p-4 rounded-lg">
      <div id="status-icon" class="flex-shrink-0"><!-- Icon --></div>
      <div>
        <div class="text-gray-400 text-sm">Current Throughput (Transactions/min)</div>
        <div id="current-throughput" class="text-5xl font-light">...</div>
      </div>
    </div>
    <div class="mt-4">
        <div class="relative w-full bg-gray-700 rounded-full h-4">
            <div id="progress-bar" class="h-4 rounded-full transition-all duration-500" style="width: 0%;"></div>
            <div id="average-line" class="absolute top-0 bottom-0 w-0.5 bg-gray-300" style="left: 66.66%;">
                 <div id="average-text" class="absolute -top-5 -translate-x-1/2 text-xs text-gray-300">...</div>
            </div>
        </div>
    </div>
    <div class="mt-5 text-center">
      <div id="status-level" class="font-semibold text-lg">...</div>
      <p id="status-message" class="text-gray-400 text-sm mt-1 h-10">...</p>
    </div>
     <div class="mt-4 border-t border-gray-700 pt-3 text-xs text-gray-500">
        <div class="flex justify-around">
            <div class="text-center"><span class="text-yellow-500 font-bold">Low:</span> <span id="legend-low"></span></div>
            <div class="text-center"><span class="text-green-500 font-bold">Normal:</span> <span id="legend-normal"></span></div>
            <div class="text-center"><span class="text-blue-500 font-bold">High:</span> <span id="legend-high"></span></div>
        </div>
    </div>
  </div>
<script>window.parent.postMessage({ action: "ready" }, "*"); 
 
window.console = new Proxy(console, {
  get(target, prop) {
    if (['log', 'warn', 'error'].includes(prop)) {
      return new Proxy(target[prop], {
        apply(fn, thisArg, args) {
          fn.apply(thisArg, args);
          window.parent.postMessage({ action: 'console', 
            type: prop, 
            args: args.map((arg) => {
              try {
                return JSON.stringify(arg).replace(/^["']|["']$/g, '');
              } catch (e) {
                return arg;
              }
            }) 
          }, '*');
        }
      });
    }
    return target[prop];
  }
});
</script></body>
</html>
